{
  "project": "solana-kit-prettified",
  "repo": "https://github.com/amilzbot/solana-kit-prettified",
  "lastUpdated": "2026-02-09",
  "tasks": [
    {
      "id": "T01",
      "phase": 0,
      "priority": 1,
      "title": "Project scaffolding",
      "description": "Init package.json (name: solana-kit-prettified), tsconfig.json (strict, declaration, declarationMap), src/ directory structure. Add @solana/kit, @solana/kit-plugins, @solana-program/system, @solana-program/token-2022, @solana-program/associated-token-account as peer deps. Set up build with tsup or tsc.",
      "status": "done",
      "notes": "Scaffolded: package.json with peer deps (@solana/kit >=6, kit-plugins, system, token-2022, ATA \u2014 all optional except kit), tsconfig (strict, declaration, declarationMap, ES2022, bundler resolution, verbatimModuleSyntax), tsup config (cjs+esm+dts), src/ with prettify.ts (Prettify + PrettifyDeep utilities) and index.ts barrel, .gitignore. Typechecks clean. Kit plugins and program deps marked optional in peerDependenciesMeta.",
      "dependsOn": []
    },
    {
      "id": "T02",
      "phase": 0,
      "priority": 2,
      "title": "Prettify utility + branded type spike",
      "description": "Implement Prettify<T> and PrettifyDeep<T> in src/prettify.ts. Create spike test file that applies Prettify to: Address, Signature, Lamports, Account, Instruction, TransactionMessage. Verify (a) branded properties are preserved, (b) hover shows flat shape, (c) types remain assignable to originals. Document findings in PLAN.md under a new 'Spike Results' section.",
      "status": "done",
      "notes": "COMPLETED. Key finding: naive Prettify strips primitive bases from branded types (Address, Lamports, Signature). Fix: added primitive guard \u2014 if T extends string|number|bigint|boolean|symbol, return T unchanged. All tests pass: (a) branded properties preserved, (b) bidirectional assignability for Account, CombinedInstruction, TransactionMessageWithFeePayer, (c) brand discrimination preserved (Address \u2260 Signature after prettify), (d) PrettifyDeep works with same guard. Spike file: src/spike.ts. Findings documented in PLAN.md under Spike Results.",
      "dependsOn": [
        "T01"
      ]
    },
    {
      "id": "T03",
      "phase": 1,
      "priority": 3,
      "title": "Core wrappers: addresses + keys",
      "description": "Create src/core/addresses.ts wrapping Address, ProgramDerivedAddress. Create src/core/keys.ts wrapping Signature, KeyPairSigner, TransactionSigner, MessageSigner. Use shallow Prettify for branded string types if spike shows deep doesn't work.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/addresses.ts (PrettyAddress, PrettyProgramDerivedAddress, PrettyProgramDerivedAddressBump) and src/core/keys.ts (PrettySignature, PrettySignatureBytes, PrettyKeyPairSigner, PrettyTransactionSigner, PrettyMessageSigner, PrettyTransactionPartialSigner, PrettyTransactionModifyingSigner, PrettyTransactionSendingSigner, PrettyMessagePartialSigner, PrettyMessageModifyingSigner). All branded primitives (Address, Signature, ProgramDerivedAddressBump) pass through Prettify unchanged via primitive guard. KeyPairSigner is the highest-value target here \u2014 it's an intersection of MessagePartialSigner & TransactionPartialSigner & { keyPair } that flattens nicely. TransactionSigner and MessageSigner are union types \u2014 Prettify distributes over each variant. All originals re-exported. Typechecks clean. Updated index.ts barrel.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T04",
      "phase": 1,
      "priority": 4,
      "title": "Core wrappers: accounts",
      "description": "Create src/core/accounts.ts wrapping Account, MaybeAccount, EncodedAccount, DecodedAccount, BaseAccount. These are intersection types (BaseAccount & { address, data }) \u2014 highest value Prettify target.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/accounts.ts with PrettyAccount, PrettyEncodedAccount, PrettyMaybeAccount, PrettyMaybeEncodedAccount, PrettyBaseAccount. Note: Kit has no 'DecodedAccount' type \u2014 Account<TData> with non-Uint8Array TData serves that role. MaybeAccount is a union \u2014 Prettify distributes over each variant. All originals re-exported. Typechecks clean.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T05",
      "phase": 1,
      "priority": 5,
      "title": "Core wrappers: instructions",
      "description": "Create src/core/instructions.ts wrapping Instruction, AccountMeta, AccountLookupMeta, InstructionWithAccounts, InstructionWithData. Instruction is an interface (less benefit) but combined types are intersections.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/instructions.ts with: PrettyAccountMeta, PrettyReadonlyAccount, PrettyWritableAccount, PrettyReadonlySignerAccount, PrettyWritableSignerAccount, PrettyAccountLookupMeta, PrettyReadonlyAccountLookup, PrettyWritableAccountLookup, PrettyInstruction, PrettyInstructionWithAccounts, PrettyInstructionWithData, PrettyCombinedInstruction. The subtype account metas (ReadonlyAccount, WritableAccount, etc.) are intersections of AccountMeta & { role: specific } \u2014 good Prettify targets. Added PrettyCombinedInstruction as a convenience type for the common Codama pattern (Instruction & InstructionWithAccounts & InstructionWithData). AccountRole re-exported as enum (no prettification needed). All originals re-exported. Typechecks clean.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T06",
      "phase": 1,
      "priority": 6,
      "title": "Core wrappers: transaction-messages + transactions",
      "description": "Create src/core/transaction-messages.ts wrapping TransactionMessage, TransactionMessageWithFeePayer, CompilableTransactionMessage. Create src/core/transactions.ts wrapping Transaction, FullySignedTransaction.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/transaction-messages.ts with: PrettyTransactionMessage, PrettyTransactionMessageWithFeePayer, PrettyBlockhashLifetimeConstraint, PrettyTransactionMessageWithBlockhashLifetime, PrettyNonceLifetimeConstraint, PrettyTransactionMessageWithDurableNonceLifetime, PrettyTransactionMessageWithLifetime, PrettyCompilableTransactionMessage (highest-value: flattens TransactionMessage & FeePayer & BlockhashLifetime intersection), PrettyCompilableTransactionMessageWithDurableNonce. Created src/core/transactions.ts with: PrettyTransaction, PrettyTransactionBlockhashLifetime, PrettyTransactionDurableNonceLifetime, PrettyTransactionWithLifetime, PrettyTransactionWithBlockhashLifetime, PrettyTransactionWithDurableNonceLifetime, PrettyFullySignedTransactionWithBlockhashLifetime, PrettySendableTransactionWithBlockhashLifetime. Nonce (branded string) passes through Prettify unchanged via primitive guard. FullySignedTransaction is a NominalType brand \u2014 also passes through. TransactionMessageBytes and Base64EncodedWireTransaction are branded Uint8Array/string \u2014 re-exported only. All originals re-exported. Typechecks clean.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T07",
      "phase": 1,
      "priority": 7,
      "title": "Core wrappers: rpc + codecs",
      "description": "Create src/core/rpc.ts wrapping Rpc, RpcSubscriptions, SolanaRpcApi, Lamports, Commitment, Slot, UnixTimestamp. Create src/core/codecs.ts wrapping Encoder, Decoder, Codec.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/rpc.ts and src/core/codecs.ts. Key findings: (1) Branded primitives (Lamports, MicroLamports, UnixTimestamp) pass through Prettify unchanged via primitive guard \u2014 re-exported directly. (2) Simple aliases (Slot, Epoch, Commitment) need no prettification \u2014 just re-exports. (3) Rpc<T>, RpcApi<T>, PendingRpcRequest<T> are mapped/generic types, not intersections \u2014 Prettify adds no tooltip value, re-exported only. (4) SolanaRpcResponse is the only type worth prettifying (Readonly intersection flattens nicely) \u2014 created PrettySolanaRpcResponse<TValue>. (5) Cluster URL types (MainnetUrl, DevnetUrl, TestnetUrl) are branded strings \u2014 pass through unchanged. (6) Codec types (Encoder, Decoder, Codec + Fixed/Variable variants) are union types of clean interfaces \u2014 no prettification value, re-exported for convenience. Also re-exported coercion functions (lamports, mainnet, devnet, testnet, etc.) and codec utilities (createEncoder, isFixedSize, etc.). Updated index.ts barrel. Typechecks clean.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T08",
      "phase": 1,
      "priority": 8,
      "title": "Core index + re-exports",
      "description": "Wire up src/core/index.ts barrel file and update src/index.ts to re-export all Phase 1 types. Ensure tree-shaking friendly exports.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/index.ts barrel re-exporting all 8 core modules. Simplified src/index.ts to export Prettify/PrettifyDeep from prettify.ts + everything from core/index.js. Build produces ESM+CJS+DTS (19.5KB .d.ts). Typecheck and build both clean. Tree-shaking friendly: all exports are type-only re-exports through barrel files.",
      "dependsOn": [
        "T03",
        "T04",
        "T05",
        "T06",
        "T07"
      ]
    },
    {
      "id": "T09",
      "phase": 1,
      "priority": 9,
      "title": "Phase 1 review: IDE hover testing",
      "description": "Create examples/hover-test.ts that imports every Pretty* type and uses them in realistic scenarios (fetch account, build instruction, send transaction). Open in VS Code, verify hover tooltips show flattened shapes. Take before/after screenshots and save to docs/screenshots/.",
      "status": "done",
      "notes": "COMPLETED. Created examples/hover-test.ts with 8 realistic scenarios covering all Pretty* types. Built examples/capture-hover.ts using TS Language Service QuickInfo API (identical to VS Code hover output) to programmatically capture before/after comparisons. Results in docs/screenshots/hover-results.md + docs/screenshots/README.md. KEY FINDINGS: (1) Major wins for intersection types: Account, EncodedAccount, MaybeAccount, CompilableTransactionMessage, KeyPairSigner all flatten from multi-intersection to single flat objects. (2) Branded primitives (Address, Signature) pass through unchanged \u2014 primitive guard works perfectly. (3) Union types (MaybeAccount, TransactionSigner, TransactionMessage) distribute correctly with each variant flattened. (4) Minor issue: CombinedInstruction shows some intersection noise in sub-fields (data: ReadonlyUint8Array & Uint8Array) \u2014 acceptable. (5) Already-flat types (Transaction) show identical output \u2014 no harm. IMPORTANT: npm install requires --include=dev flag (global npm config has omit=['dev']). Quality gate: PASSED.",
      "dependsOn": [
        "T08"
      ]
    },
    {
      "id": "T10",
      "phase": 1,
      "priority": 10,
      "title": "Phase 1 review: type compatibility tests",
      "description": "Set up vitest or tsd for type testing. Write tests confirming: (a) Pretty* types are assignable to originals, (b) originals are assignable to Pretty* types, (c) branded type discrimination still works (e.g. Address not assignable to Signature). Run in CI.",
      "status": "done",
      "notes": "COMPLETED. Set up vitest + expect-type for compile-time type assertions. 30 tests covering: (a) bidirectional assignability for all Pretty* types across addresses, keys/signers, accounts, instructions, transaction-messages, transactions; (b) generic variants (PrettyAccount<MyData>, PrettyAddress<'abc'>); (c) branded discrimination (Address \u2260 Signature, PrettyAddress \u2260 PrettySignature, cross-pretty/original). All 30 pass. Note: Kit's Account/MaybeAccount require explicit type args (no defaults) \u2014 tests use <Uint8Array> explicitly. Added vitest.config.ts, npm test script. Dev deps: vitest, expect-type.",
      "dependsOn": [
        "T08"
      ]
    },
    {
      "id": "T11",
      "phase": 2,
      "priority": 11,
      "title": "Plugin wrappers: client return types",
      "description": "Create src/plugins/clients.ts. Extract and prettify the return types of createDefaultRpcClient, createDefaultLocalhostRpcClient, createDefaultLiteSVMClient. These are chained .use() intersection types \u2014 among the worst tooltip offenders.",
      "status": "done",
      "notes": "COMPLETED. Created src/plugins/clients.ts with PrettyDefaultRpcClient, PrettyDefaultLocalhostRpcClient, PrettyDefaultLiteSVMClient. Approach: ReturnType<typeof factory> extracts Client<T>/AsyncClient<T>, then a conditional type extracts T from Client/AsyncClient (stripping the `use` method), then Prettify flattens the chained .use() intersection. All three resolve to non-never types with expected properties verified (rpc, payer, sendTransaction, svm, airdrop). Added @solana/kit-plugins as devDependency. Created src/plugins/index.ts barrel. Updated src/index.ts to re-export plugins. Build produces 23KB .d.ts. All 30 existing type tests still pass. Key: Client<T> = T & { use }, so extracting T from the conditional already gives us the clean shape before Prettify flattens it further.",
      "dependsOn": [
        "T09",
        "T10"
      ]
    },
    {
      "id": "T12",
      "phase": 2,
      "priority": 12,
      "title": "Plugin wrappers: plans + executor",
      "description": "Create src/plugins/plans.ts wrapping TransactionPlan, SingleTransactionPlan, ParallelTransactionPlan, SequentialTransactionPlan, TransactionPlanResult, TransactionPlanExecutor, TransactionPlanExecutorConfig.",
      "status": "done",
      "notes": "COMPLETED. Created src/plugins/plans.ts with Pretty* wrappers for all instruction-plans types: InstructionPlan variants (PrettySingleInstructionPlan, PrettySequentialInstructionPlan, PrettyParallelInstructionPlan, PrettyMessagePackerInstructionPlan, PrettyMessagePacker), TransactionPlan variants (PrettySingleTransactionPlan, PrettySequentialTransactionPlan, PrettyParallelTransactionPlan), TransactionPlanResult variants (PrettySuccessfulSingleTransactionPlanResult, PrettyFailedSingleTransactionPlanResult, PrettyCanceledSingleTransactionPlanResult, PrettySequentialTransactionPlanResult, PrettyParallelTransactionPlanResult), context types (PrettyBaseTransactionPlanResultContext, PrettySuccessfulBaseTransactionPlanResultContext), and config types (PrettyTransactionPlanExecutorConfig, PrettyTransactionPlannerConfig). All types are Readonly<{...}> objects \u2014 Prettify removes the Readonly wrapper noise in tooltips. Generic params preserved for all parameterized types. All originals re-exported. TransactionPlanExecutor and TransactionPlanner are function types \u2014 re-exported only (no prettification value). Updated plugins/index.ts barrel. Build produces 29.5KB .d.ts. All 30 existing tests pass. Typecheck clean.",
      "dependsOn": [
        "T09",
        "T10"
      ]
    },
    {
      "id": "T13",
      "phase": 2,
      "priority": 13,
      "title": "Plugin wrappers: individual plugin configs",
      "description": "Wrap config/option types from individual plugin packages: rpc, payer, airdrop, litesvm, sendTransactions, defaultTransactionPlannerAndExecutorFromRpc.",
      "status": "pending",
      "notes": "Source: kit-plugins/packages/kit-plugin-*/src/. Each plugin exports its own config types.",
      "dependsOn": [
        "T11"
      ]
    },
    {
      "id": "T14",
      "phase": 2,
      "priority": 14,
      "title": "Phase 2 review: IDE hover + type compat tests",
      "description": "Same drill as T09/T10 but for plugin types. Focus on client return types \u2014 verify the chained .use() intersection flattens into a readable client shape.",
      "status": "pending",
      "notes": "",
      "dependsOn": [
        "T11",
        "T12",
        "T13"
      ]
    },
    {
      "id": "T15",
      "phase": 3,
      "priority": 15,
      "title": "Program wrappers: system",
      "description": "Create src/programs/system.ts. Wrap all Codama-generated instruction types from @solana-program/system: TransferSolInstruction, CreateAccountInstruction, AllocateInstruction, AssignInstruction, AdvanceNonceAccountInstruction, etc. Also wrap *Input types. Focus on instruction return types (multi-intersection: Instruction & InstructionWithData & InstructionWithAccounts).",
      "status": "pending",
      "notes": "Source: _ref/system/clients/js/src/generated/instructions/. Instructions are: transferSol, createAccount, allocate, allocateWithSeed, assign, assignWithSeed, advanceNonceAccount, authorizeNonceAccount, initializeNonceAccount, withdrawNonceAccount, upgradeNonceAccount, createAccountWithSeed, transferSolWithSeed.",
      "dependsOn": [
        "T14"
      ]
    },
    {
      "id": "T16",
      "phase": 3,
      "priority": 16,
      "title": "Program wrappers: token",
      "description": "Create src/programs/token.ts. Wrap instruction types + Mint and Token (token account) decoded account types from @solana-program/token.",
      "status": "pending",
      "notes": "Token and Token-2022 share similar structures. Do token first, then extend for 2022.",
      "dependsOn": [
        "T14"
      ]
    },
    {
      "id": "T17",
      "phase": 3,
      "priority": 17,
      "title": "Program wrappers: token-2022",
      "description": "Create src/programs/token-2022.ts. Extend token wrappers with token-2022 extension types: TransferFeeConfig, ConfidentialTransferMint, InterestBearingConfig, MintCloseAuthority, DefaultAccountState, etc.",
      "status": "pending",
      "notes": "Source: _ref/token-2022/clients/js-v1/src/generated/. Most complex program \u2014 many extension types.",
      "dependsOn": [
        "T16"
      ]
    },
    {
      "id": "T18",
      "phase": 3,
      "priority": 18,
      "title": "Program wrappers: associated-token-account + memo",
      "description": "Create src/programs/associated-token.ts for ATA instruction types. Optionally add memo if worthwhile.",
      "status": "pending",
      "notes": "",
      "dependsOn": [
        "T14"
      ]
    },
    {
      "id": "T19",
      "phase": 3,
      "priority": 19,
      "title": "Phase 3 review: IDE hover + type compat tests",
      "description": "Verify all Codama-generated program types flatten properly. Special attention to generic-heavy instruction types with 4+ type params.",
      "status": "pending",
      "notes": "Codama types may need per-instruction treatment rather than blanket Prettify if generics interact poorly.",
      "dependsOn": [
        "T15",
        "T16",
        "T17",
        "T18"
      ]
    },
    {
      "id": "T20",
      "phase": 4,
      "priority": 20,
      "title": "CI setup",
      "description": "GitHub Actions workflow: type-check against latest Kit + program client releases. Run type compat tests. Weekly cron to catch breakage.",
      "status": "pending",
      "notes": "",
      "dependsOn": [
        "T19"
      ]
    },
    {
      "id": "T21",
      "phase": 4,
      "priority": 21,
      "title": "README + documentation",
      "description": "Write README with: problem statement, before/after IDE screenshots, installation, usage examples, which types are covered. Add CONTRIBUTING.md.",
      "status": "pending",
      "notes": "",
      "dependsOn": [
        "T19"
      ]
    },
    {
      "id": "T22",
      "phase": 4,
      "priority": 22,
      "title": "npm publish",
      "description": "Publish to npm as solana-kit-prettified. Set up semantic versioning. Add provenance.",
      "status": "pending",
      "notes": "",
      "dependsOn": [
        "T20",
        "T21"
      ]
    }
  ]
}