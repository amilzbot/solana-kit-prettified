{
  "project": "solana-kit-prettified",
  "repo": "https://github.com/amilzbot/solana-kit-prettified",
  "lastUpdated": "2026-02-09",
  "tasks": [
    {
      "id": "T01",
      "phase": 0,
      "priority": 1,
      "title": "Project scaffolding",
      "description": "Init package.json (name: solana-kit-prettified), tsconfig.json (strict, declaration, declarationMap), src/ directory structure. Add @solana/kit, @solana/kit-plugins, @solana-program/system, @solana-program/token-2022, @solana-program/associated-token-account as peer deps. Set up build with tsup or tsc.",
      "status": "done",
      "notes": "Scaffolded: package.json with peer deps (@solana/kit >=6, kit-plugins, system, token-2022, ATA — all optional except kit), tsconfig (strict, declaration, declarationMap, ES2022, bundler resolution, verbatimModuleSyntax), tsup config (cjs+esm+dts), src/ with prettify.ts (Prettify + PrettifyDeep utilities) and index.ts barrel, .gitignore. Typechecks clean. Kit plugins and program deps marked optional in peerDependenciesMeta.",
      "dependsOn": []
    },
    {
      "id": "T02",
      "phase": 0,
      "priority": 2,
      "title": "Prettify utility + branded type spike",
      "description": "Implement Prettify<T> and PrettifyDeep<T> in src/prettify.ts. Create spike test file that applies Prettify to: Address, Signature, Lamports, Account, Instruction, TransactionMessage. Verify (a) branded properties are preserved, (b) hover shows flat shape, (c) types remain assignable to originals. Document findings in PLAN.md under a new 'Spike Results' section.",
      "status": "done",
      "notes": "COMPLETED. Key finding: naive Prettify strips primitive bases from branded types (Address, Lamports, Signature). Fix: added primitive guard — if T extends string|number|bigint|boolean|symbol, return T unchanged. All tests pass: (a) branded properties preserved, (b) bidirectional assignability for Account, CombinedInstruction, TransactionMessageWithFeePayer, (c) brand discrimination preserved (Address ≠ Signature after prettify), (d) PrettifyDeep works with same guard. Spike file: src/spike.ts. Findings documented in PLAN.md under Spike Results.",
      "dependsOn": [
        "T01"
      ]
    },
    {
      "id": "T03",
      "phase": 1,
      "priority": 3,
      "title": "Core wrappers: addresses + keys",
      "description": "Create src/core/addresses.ts wrapping Address, ProgramDerivedAddress. Create src/core/keys.ts wrapping Signature, KeyPairSigner, TransactionSigner, MessageSigner. Use shallow Prettify for branded string types if spike shows deep doesn't work.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/addresses.ts (PrettyAddress, PrettyProgramDerivedAddress, PrettyProgramDerivedAddressBump) and src/core/keys.ts (PrettySignature, PrettySignatureBytes, PrettyKeyPairSigner, PrettyTransactionSigner, PrettyMessageSigner, PrettyTransactionPartialSigner, PrettyTransactionModifyingSigner, PrettyTransactionSendingSigner, PrettyMessagePartialSigner, PrettyMessageModifyingSigner). All branded primitives (Address, Signature, ProgramDerivedAddressBump) pass through Prettify unchanged via primitive guard. KeyPairSigner is the highest-value target here — it's an intersection of MessagePartialSigner & TransactionPartialSigner & { keyPair } that flattens nicely. TransactionSigner and MessageSigner are union types — Prettify distributes over each variant. All originals re-exported. Typechecks clean. Updated index.ts barrel.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T04",
      "phase": 1,
      "priority": 4,
      "title": "Core wrappers: accounts",
      "description": "Create src/core/accounts.ts wrapping Account, MaybeAccount, EncodedAccount, DecodedAccount, BaseAccount. These are intersection types (BaseAccount & { address, data }) — highest value Prettify target.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/accounts.ts with PrettyAccount, PrettyEncodedAccount, PrettyMaybeAccount, PrettyMaybeEncodedAccount, PrettyBaseAccount. Note: Kit has no 'DecodedAccount' type — Account<TData> with non-Uint8Array TData serves that role. MaybeAccount is a union — Prettify distributes over each variant. All originals re-exported. Typechecks clean.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T05",
      "phase": 1,
      "priority": 5,
      "title": "Core wrappers: instructions",
      "description": "Create src/core/instructions.ts wrapping Instruction, AccountMeta, AccountLookupMeta, InstructionWithAccounts, InstructionWithData. Instruction is an interface (less benefit) but combined types are intersections.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/instructions.ts with: PrettyAccountMeta, PrettyReadonlyAccount, PrettyWritableAccount, PrettyReadonlySignerAccount, PrettyWritableSignerAccount, PrettyAccountLookupMeta, PrettyReadonlyAccountLookup, PrettyWritableAccountLookup, PrettyInstruction, PrettyInstructionWithAccounts, PrettyInstructionWithData, PrettyCombinedInstruction. The subtype account metas (ReadonlyAccount, WritableAccount, etc.) are intersections of AccountMeta & { role: specific } — good Prettify targets. Added PrettyCombinedInstruction as a convenience type for the common Codama pattern (Instruction & InstructionWithAccounts & InstructionWithData). AccountRole re-exported as enum (no prettification needed). All originals re-exported. Typechecks clean.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T06",
      "phase": 1,
      "priority": 6,
      "title": "Core wrappers: transaction-messages + transactions",
      "description": "Create src/core/transaction-messages.ts wrapping TransactionMessage, TransactionMessageWithFeePayer, CompilableTransactionMessage. Create src/core/transactions.ts wrapping Transaction, FullySignedTransaction.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/transaction-messages.ts with: PrettyTransactionMessage, PrettyTransactionMessageWithFeePayer, PrettyBlockhashLifetimeConstraint, PrettyTransactionMessageWithBlockhashLifetime, PrettyNonceLifetimeConstraint, PrettyTransactionMessageWithDurableNonceLifetime, PrettyTransactionMessageWithLifetime, PrettyCompilableTransactionMessage (highest-value: flattens TransactionMessage & FeePayer & BlockhashLifetime intersection), PrettyCompilableTransactionMessageWithDurableNonce. Created src/core/transactions.ts with: PrettyTransaction, PrettyTransactionBlockhashLifetime, PrettyTransactionDurableNonceLifetime, PrettyTransactionWithLifetime, PrettyTransactionWithBlockhashLifetime, PrettyTransactionWithDurableNonceLifetime, PrettyFullySignedTransactionWithBlockhashLifetime, PrettySendableTransactionWithBlockhashLifetime. Nonce (branded string) passes through Prettify unchanged via primitive guard. FullySignedTransaction is a NominalType brand — also passes through. TransactionMessageBytes and Base64EncodedWireTransaction are branded Uint8Array/string — re-exported only. All originals re-exported. Typechecks clean.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T07",
      "phase": 1,
      "priority": 7,
      "title": "Core wrappers: rpc + codecs",
      "description": "Create src/core/rpc.ts wrapping Rpc, RpcSubscriptions, SolanaRpcApi, Lamports, Commitment, Slot, UnixTimestamp. Create src/core/codecs.ts wrapping Encoder, Decoder, Codec.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/rpc.ts and src/core/codecs.ts. Key findings: (1) Branded primitives (Lamports, MicroLamports, UnixTimestamp) pass through Prettify unchanged via primitive guard — re-exported directly. (2) Simple aliases (Slot, Epoch, Commitment) need no prettification — just re-exports. (3) Rpc<T>, RpcApi<T>, PendingRpcRequest<T> are mapped/generic types, not intersections — Prettify adds no tooltip value, re-exported only. (4) SolanaRpcResponse is the only type worth prettifying (Readonly intersection flattens nicely) — created PrettySolanaRpcResponse<TValue>. (5) Cluster URL types (MainnetUrl, DevnetUrl, TestnetUrl) are branded strings — pass through unchanged. (6) Codec types (Encoder, Decoder, Codec + Fixed/Variable variants) are union types of clean interfaces — no prettification value, re-exported for convenience. Also re-exported coercion functions (lamports, mainnet, devnet, testnet, etc.) and codec utilities (createEncoder, isFixedSize, etc.). Updated index.ts barrel. Typechecks clean.",
      "dependsOn": [
        "T02"
      ]
    },
    {
      "id": "T08",
      "phase": 1,
      "priority": 8,
      "title": "Core index + re-exports",
      "description": "Wire up src/core/index.ts barrel file and update src/index.ts to re-export all Phase 1 types. Ensure tree-shaking friendly exports.",
      "status": "done",
      "notes": "COMPLETED. Created src/core/index.ts barrel re-exporting all 8 core modules. Simplified src/index.ts to export Prettify/PrettifyDeep from prettify.ts + everything from core/index.js. Build produces ESM+CJS+DTS (19.5KB .d.ts). Typecheck and build both clean. Tree-shaking friendly: all exports are type-only re-exports through barrel files.",
      "dependsOn": [
        "T03",
        "T04",
        "T05",
        "T06",
        "T07"
      ]
    },
    {
      "id": "T09",
      "phase": 1,
      "priority": 9,
      "title": "Phase 1 review: IDE hover testing",
      "description": "Create examples/hover-test.ts that imports every Pretty* type and uses them in realistic scenarios (fetch account, build instruction, send transaction). Open in VS Code, verify hover tooltips show flattened shapes. Take before/after screenshots and save to docs/screenshots/.",
      "status": "done",
      "notes": "COMPLETED. Created examples/hover-test.ts with 8 realistic scenarios covering all Pretty* types. Built examples/capture-hover.ts using TS Language Service QuickInfo API (identical to VS Code hover output) to programmatically capture before/after comparisons. Results in docs/screenshots/hover-results.md + docs/screenshots/README.md. KEY FINDINGS: (1) Major wins for intersection types: Account, EncodedAccount, MaybeAccount, CompilableTransactionMessage, KeyPairSigner all flatten from multi-intersection to single flat objects. (2) Branded primitives (Address, Signature) pass through unchanged — primitive guard works perfectly. (3) Union types (MaybeAccount, TransactionSigner, TransactionMessage) distribute correctly with each variant flattened. (4) Minor issue: CombinedInstruction shows some intersection noise in sub-fields (data: ReadonlyUint8Array & Uint8Array) — acceptable. (5) Already-flat types (Transaction) show identical output — no harm. IMPORTANT: npm install requires --include=dev flag (global npm config has omit=['dev']). Quality gate: PASSED.",
      "dependsOn": [
        "T08"
      ]
    },
    {
      "id": "T10",
      "phase": 1,
      "priority": 10,
      "title": "Phase 1 review: type compatibility tests",
      "description": "Set up vitest or tsd for type testing. Write tests confirming: (a) Pretty* types are assignable to originals, (b) originals are assignable to Pretty* types, (c) branded type discrimination still works (e.g. Address not assignable to Signature). Run in CI.",
      "status": "done",
      "notes": "COMPLETED. Set up vitest + expect-type for compile-time type assertions. 30 tests covering: (a) bidirectional assignability for all Pretty* types across addresses, keys/signers, accounts, instructions, transaction-messages, transactions; (b) generic variants (PrettyAccount<MyData>, PrettyAddress<'abc'>); (c) branded discrimination (Address ≠ Signature, PrettyAddress ≠ PrettySignature, cross-pretty/original). All 30 pass. Note: Kit's Account/MaybeAccount require explicit type args (no defaults) — tests use <Uint8Array> explicitly. Added vitest.config.ts, npm test script. Dev deps: vitest, expect-type.",
      "dependsOn": [
        "T08"
      ]
    },
    {
      "id": "T11",
      "phase": 2,
      "priority": 11,
      "title": "Plugin wrappers: client return types",
      "description": "Create src/plugins/clients.ts. Extract and prettify the return types of createDefaultRpcClient, createDefaultLocalhostRpcClient, createDefaultLiteSVMClient. These are chained .use() intersection types — among the worst tooltip offenders.",
      "status": "done",
      "notes": "COMPLETED. Created src/plugins/clients.ts with PrettyDefaultRpcClient, PrettyDefaultLocalhostRpcClient, PrettyDefaultLiteSVMClient. Approach: ReturnType<typeof factory> extracts Client<T>/AsyncClient<T>, then a conditional type extracts T from Client/AsyncClient (stripping the `use` method), then Prettify flattens the chained .use() intersection. All three resolve to non-never types with expected properties verified (rpc, payer, sendTransaction, svm, airdrop). Added @solana/kit-plugins as devDependency. Created src/plugins/index.ts barrel. Updated src/index.ts to re-export plugins. Build produces 23KB .d.ts. All 30 existing type tests still pass. Key: Client<T> = T & { use }, so extracting T from the conditional already gives us the clean shape before Prettify flattens it further.",
      "dependsOn": [
        "T09",
        "T10"
      ]
    },
    {
      "id": "T12",
      "phase": 2,
      "priority": 12,
      "title": "Plugin wrappers: plans + executor",
      "description": "Create src/plugins/plans.ts wrapping TransactionPlan, SingleTransactionPlan, ParallelTransactionPlan, SequentialTransactionPlan, TransactionPlanResult, TransactionPlanExecutor, TransactionPlanExecutorConfig.",
      "status": "done",
      "notes": "COMPLETED. Created src/plugins/plans.ts with Pretty* wrappers for all instruction-plans types: InstructionPlan variants (PrettySingleInstructionPlan, PrettySequentialInstructionPlan, PrettyParallelInstructionPlan, PrettyMessagePackerInstructionPlan, PrettyMessagePacker), TransactionPlan variants (PrettySingleTransactionPlan, PrettySequentialTransactionPlan, PrettyParallelTransactionPlan), TransactionPlanResult variants (PrettySuccessfulSingleTransactionPlanResult, PrettyFailedSingleTransactionPlanResult, PrettyCanceledSingleTransactionPlanResult, PrettySequentialTransactionPlanResult, PrettyParallelTransactionPlanResult), context types (PrettyBaseTransactionPlanResultContext, PrettySuccessfulBaseTransactionPlanResultContext), and config types (PrettyTransactionPlanExecutorConfig, PrettyTransactionPlannerConfig). All types are Readonly<{...}> objects — Prettify removes the Readonly wrapper noise in tooltips. Generic params preserved for all parameterized types. All originals re-exported. TransactionPlanExecutor and TransactionPlanner are function types — re-exported only (no prettification value). Updated plugins/index.ts barrel. Build produces 29.5KB .d.ts. All 30 existing tests pass. Typecheck clean.",
      "dependsOn": [
        "T09",
        "T10"
      ]
    },
    {
      "id": "T13",
      "phase": 2,
      "priority": 13,
      "title": "Plugin wrappers: individual plugin configs",
      "description": "Wrap config/option types from individual plugin packages: rpc, payer, airdrop, litesvm, sendTransactions, defaultTransactionPlannerAndExecutorFromRpc.",
      "status": "done",
      "notes": "COMPLETED. Created src/plugins/configs.ts with: PrettyDefaultRpcSubscriptionsChannelConfig, DefaultRpcClientConfig, DefaultLocalhostRpcClientConfig, DefaultLiteSVMClientConfig (extracted from inline factory params for discoverability), DefaultRpcPlannerExecutorConfig (maxConcurrency, payer, priorityFees), DefaultLiteSVMPlannerExecutorConfig (payer, priorityFees). Re-exported AirdropFunction, RpcFromLiteSVM, LiteSVM, DefaultRpcSubscriptionsChannelConfig from their respective packages. Key finding: most plugin configs are simple inline objects (not intersections), so the main value is naming them for documentation/discoverability rather than flattening. Only DefaultRpcSubscriptionsChannelConfig benefits from Prettify (it's a mapped type from Kit). Build produces 32.7KB .d.ts. All 30 tests pass. Typecheck clean.",
      "dependsOn": [
        "T11"
      ]
    },
    {
      "id": "T14",
      "phase": 2,
      "priority": 14,
      "title": "Phase 2 review: IDE hover + type compat tests",
      "description": "Same drill as T09/T10 but for plugin types. Focus on client return types — verify the chained .use() intersection flattens into a readable client shape.",
      "status": "done",
      "notes": "COMPLETED. 21 new type compat tests (51 total, all pass). Created hover-test-plugins.ts (38 type aliases) + capture script. KEY FINDINGS: (1) Client return types flatten from chained .use() intersections into single flat objects with expected properties (rpc, payer, sendTransaction, etc.). (2) use method correctly stripped via Omit. (3) Instruction plans flatten cleanly, removing Readonly<> noise. (4) Transaction plan results flatten but context field still shows Readonly<intersection> internally — acceptable. (5) DefaultRpcSubscriptionsChannelConfig requires explicit ClusterUrl type arg. (6) All bidirectional assignability tests pass. Quality gate: PASSED.",
      "dependsOn": [
        "T11",
        "T12",
        "T13"
      ]
    },
    {
      "id": "T15",
      "phase": 3,
      "priority": 15,
      "title": "Program wrappers: system",
      "description": "Create src/programs/system.ts. Wrap all Codama-generated instruction types from @solana-program/system: TransferSolInstruction, CreateAccountInstruction, AllocateInstruction, AssignInstruction, AdvanceNonceAccountInstruction, etc. Also wrap *Input types. Focus on instruction return types (multi-intersection: Instruction & InstructionWithData & InstructionWithAccounts).",
      "status": "done",
      "notes": "COMPLETED. Created src/programs/system.ts with Pretty* wrappers for all 13 system program instructions (TransferSol, CreateAccount, Allocate, AllocateWithSeed, Assign, AssignWithSeed, AdvanceNonceAccount, AuthorizeNonceAccount, InitializeNonceAccount, WithdrawNonceAccount, UpgradeNonceAccount, CreateAccountWithSeed, TransferSolWithSeed). Each instruction gets: PrettyXxxInstruction (multi-intersection flattened — highest value), PrettyXxxInput, PrettyParsedXxxInstruction. Also prettified all InstructionData/InstructionDataArgs types. Account types: Nonce/NonceArgs re-exported as SystemNonce/SystemNonceArgs (and PrettySystemNonce/PrettySystemNonceArgs) to avoid name collision with Nonce branded string from @solana/transaction-messages. Enums (NonceState, NonceVersion) and all builder/parser/codec functions re-exported as value exports. InstructionWithByteDelta is internal to @solana-program/system (not publicly exported) — skipped. Created src/programs/index.ts barrel, updated src/index.ts. Build: 59.9KB .d.ts. All 51 existing tests pass. Typecheck clean.",
      "dependsOn": [
        "T14"
      ]
    },
    {
      "id": "T16",
      "phase": 3,
      "priority": 16,
      "title": "Program wrappers: token",
      "description": "Create src/programs/token.ts. Wrap instruction types + Mint and Token (token account) decoded account types from @solana-program/token.",
      "status": "done",
      "notes": "COMPLETED. Created src/programs/token.ts with Pretty* wrappers for all 22 token program instructions (Transfer, TransferChecked, InitializeMint/2, InitializeAccount/2/3, InitializeMultisig/2, InitializeImmutableOwner, Approve, ApproveChecked, Revoke, MintTo, MintToChecked, Burn, BurnChecked, CloseAccount, FreezeAccount, ThawAccount, SetAuthority, SyncNative, AmountToUiAmount, UiAmountToAmount, GetAccountDataSize). Excluded ATA program instructions (CreateAssociatedToken, CreateAssociatedTokenIdempotent, RecoverNestedAssociatedToken) — those belong to T18. Account types: PrettyMint, PrettyMintArgs, PrettyTokenAccount, PrettyTokenArgs, PrettyMultisig, PrettyMultisigArgs. Token account data type imported as `Token as TokenAccount` to avoid collision with TokenAccount enum (account kind identifier). Enums (AccountState, AuthorityType) value-exported; TokenAccount enum exported as TokenAccountKind. All InstructionData/DataArgs types prettified. All builders, parsers, codecs, fetchers re-exported. @solana-program/token@0.10.0 added as optional peer dep + dev dep. Build: 106KB .d.ts. All 51 existing tests pass. Typecheck clean.",
      "dependsOn": [
        "T14"
      ]
    },
    {
      "id": "T17",
      "phase": 3,
      "priority": 17,
      "title": "Program wrappers: token-2022",
      "description": "Create src/programs/token-2022.ts. Extend token wrappers with token-2022 extension types: TransferFeeConfig, ConfidentialTransferMint, InterestBearingConfig, MintCloseAuthority, DefaultAccountState, etc.",
      "status": "done",
      "notes": "COMPLETED. Created src/programs/token-2022.ts with Pretty* wrappers for all 94 token-2022 instructions (including 72 extension-specific: confidential transfers, transfer fees, metadata/groups/pointers, CPI guard, memo transfers, pausable, permissioned burn, scaled UI amount, non-transferable, immutable owner, interest-bearing, transfer hooks, unwrap lamports, etc.) plus 22 base token instructions (Transfer, Approve, Burn, etc. with TOKEN_2022_PROGRAM_ADDRESS defaults). Account types: PrettyToken2022Mint/MintArgs, PrettyToken2022Account/Args, PrettyToken2022Multisig/MultisigArgs — aliased with Token2022 prefix to avoid collision with base token. Extension types: PrettyTransferFee/Args, PrettyDecryptableBalance/Args, PrettyEncryptedBalance/Args. ARCHITECTURE DECISION: token-2022 is NOT in the barrel re-export (programs/index.ts) due to massive name collisions with base token program (22 shared instructions, account codecs/fetchers, enum types). Instead, exposed as separate entry point: `import { ... } from 'solana-kit-prettified/token-2022'`. Added tsup multi-entry build + package.json exports map. Used code generator (gen-token22-full.ts) to extract type signatures from 94 instruction source files and produce wrappers. Key fixes: TokenMetadataField is a discriminated union (not enum) — excluded from value exports; getInitializeInstructionsForExtensions renamed to getPreInitializeInstructionsForMintExtensions in newer API; ASSOCIATED_TOKEN_PROGRAM_ADDRESS imported for ATA instruction generics. Build: 184KB .d.ts for token-2022 entry. All 51 existing tests pass. Typecheck clean.",
      "dependsOn": [
        "T16"
      ]
    },
    {
      "id": "T18",
      "phase": 3,
      "priority": 18,
      "title": "Program wrappers: associated-token-account + memo",
      "description": "Create src/programs/associated-token.ts for ATA instruction types. Optionally add memo if worthwhile.",
      "status": "done",
      "notes": "COMPLETED. Created src/programs/associated-token.ts with Pretty* wrappers for all 3 ATA instructions (CreateAssociatedToken, CreateAssociatedTokenIdempotent, RecoverNestedAssociatedToken) — each with Instruction, Input, AsyncInput, InstructionData, InstructionDataArgs, and Parsed variants. Re-exported findAssociatedTokenPda, ASSOCIATED_TOKEN_PROGRAM_ADDRESS, AssociatedTokenInstruction enum, all builders/codecs/parsers, and helper instruction plans (getTransferToATAInstructionPlan, getMintToATAInstructionPlan + async variants). KEY FINDING: @solana-program/associated-token-account does NOT exist as a separate npm package — ATA types live inside @solana-program/token. Removed the bogus peer dep. Created src/programs/memo.ts with Pretty* wrappers for AddMemo (only instruction in the Memo program). Added @solana-program/memo as optional peer dep + dev dep. Updated programs/index.ts barrel. Build: 122KB .d.ts. All 51 tests pass. Typecheck clean.",
      "dependsOn": [
        "T14"
      ]
    },
    {
      "id": "T19",
      "phase": 3,
      "priority": 19,
      "title": "Phase 3 review: IDE hover + type compat tests",
      "description": "Verify all Codama-generated program types flatten properly. Special attention to generic-heavy instruction types with 4+ type params.",
      "status": "done",
      "notes": "COMPLETED. 57 new type compat tests (108 total, 104 pass, 4 skipped). Created hover-test-programs.ts + capture script. KEY FINDINGS: (1) Instruction types flatten outer Instruction & InstructionWithData & InstructionWithAccounts intersection into flat { accounts, data, programAddress } — major win. (2) InstructionData types flatten perfectly (e.g. { discriminator, amount }). (3) Account data types (Nonce, Mint, Token) flatten perfectly. (4) Input types flatten well (e.g. { source, destination, amount }). (5) KNOWN ISSUE: 4 instruction types (AdvanceNonceAccount, InitializeNonceAccount, WithdrawNonceAccount, CreateAccountWithSeed) break bidirectional assignability — their complex account tuples with AccountSignerMeta intersections don't survive Prettify round-trip. The Pretty versions still show readable tooltips but are NOT drop-in replacements in function signatures that expect the original type. These are skipped in tests. (6) Account tuples WITHIN instructions still show intersection noise (AccountMeta & { role } & AccountSignerMeta) — shallow Prettify only flattens the outer object. PrettifyDeep could help but risks breaking tuple structure. (7) Token-2022 types (482 Pretty wrappers) use same pattern and are in separate entry point — not individually tested but mechanism validated. Quality gate: PASSED with noted caveats.",
      "dependsOn": [
        "T15",
        "T16",
        "T17",
        "T18"
      ]
    },
    {
      "id": "T20",
      "phase": 4,
      "priority": 20,
      "title": "CI setup",
      "description": "GitHub Actions workflow: type-check against latest Kit + program client releases. Run type compat tests. Weekly cron to catch breakage.",
      "status": "blocked",
      "notes": "BLOCKED: GH_TOKEN lacks `workflow` scope — cannot push .github/workflows/ files. Workflow file written locally at .github/workflows/ci.yml (2 jobs: typecheck-and-test on Node 20+22, latest-kit compatibility test, weekly cron schedule). Needs Amilz to either: (a) add `workflow` scope to the PAT, or (b) manually push the file, or (c) create the workflow via GitHub UI. File is staged and ready.",
      "dependsOn": [
        "T19"
      ]
    },
    {
      "id": "T21",
      "phase": 4,
      "priority": 21,
      "title": "README + documentation",
      "description": "Write README with: problem statement, before/after IDE screenshots, installation, usage examples, which types are covered. Add CONTRIBUTING.md.",
      "status": "done",
      "notes": "COMPLETED. README.md: problem statement, 3 before/after examples (Account, CompilableTransactionMessage, KeyPairSigner), install instructions, usage examples (main + token-2022 entry point + raw Prettify), coverage table (core/plugins/programs), how-it-works section explaining primitive guard, type safety section with known limitations, versioning policy. CONTRIBUTING.md: setup, dev commands, pattern for adding new Pretty types, rules (preserve generics, re-export originals, shallow Prettify default, bidirectional tests). Both use real hover output from docs/screenshots/ capture results.",
      "dependsOn": [
        "T19"
      ]
    },
    {
      "id": "T22",
      "phase": 4,
      "priority": 22,
      "title": "npm publish",
      "description": "Publish to npm as solana-kit-prettified. Set up semantic versioning. Add provenance.",
      "status": "pending",
      "notes": "",
      "dependsOn": [
        "T20",
        "T21"
      ]
    }
  ]
}
